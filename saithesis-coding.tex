The pseudocode presented in Section~\ref{S:algorithm overview} provides the 
basic framework for the application of our algorithm.
For cases where the MLE is known to exist and  the gradient $\nabla \ell(\eta)$  
cannot be calculated exactly, an appropriate MCMC sampler can be used to 
approximate this quantity as described in Section~\ref{S:MCMC approx}.  
An efficient root finding algorithm to find a step size $\alpha_k$ that satisfies the 
curvature condition \eqref{E:Wolfe-ll} is also highly desirable (and is in fact
an area for further research).  However, the overall algorithm
is essentially the same.

Some modification is required for the setting where the MLE may not exist.  
We need to apply the theory developed in Section~\ref{S:LCM}, which
relies heavily on linear programming methodologies.  For example, even when coordinates 
of a point $g(\yobs)$ and the vertices that define a convex polytope $C$ are known, it 
is not a trivial matter to know if that point lies in the exterior, interior, 
or exactly on a boundary of $C$.  
%Furthermore, in the general case that we are considering, we do not assume this 
%convex support $C$ to be known in advance, and thus must combine a way to explore the
%sample space while simultaneously 
Further complicating this process is that the representation of 
numbers in computers is not exact, e.g., \texttt{0.3 / 3 == 1} evaluates
to \texttt{FALSE}.  Fortunately most of the tools we need have already 
been made available to us through the \texttt{rcdd} package \citep{rcdd:R} in R.  

In this chapter, we first present an expanded pseudocode to handle the possible
non-existence of MLEs: when the algorithm determines that the MLE does not exist
in the original model, it then finds a GDOR and proceeds to maximize the LCM to
find the MLE in the LCM.  
We then point out the specific functionality that is necessary,
and describe the commands by which each of these operations can be performed in R.
We do not provide theoretical derivations for the linear programming operations here
and refer the interested reader to \citep{Fukuda:2004,Fukuda:2008}.

\newpage
\section{Algorithm pseudocode}
%Below are a few comments about notation and equations:
%\begin{itemize}
%\item $C$ is the convex support.
%\item $Y$ is the random variable in the sample space.
%\item $g(\cdot)$ is the function that maps $y$ to its natural statistics.
%\item $\yobs$ is the observed observed, $g(\yobs)$ the natural statistics of the observed data.
%%\item $\con()$ is the convex hull of a set of points.
%%\item $\rbd()$ is the relative boundary of a set of points.
%\item $\norm{\cdot}$ is the Euclidean norm.
%%\item The curvature condition \eqref{E:Wolfe-ll} used here comes from the search 
%%algorithm of \citet{Okabayashi:longrange} and is necessary for guaranteeing 
%%convergence to the MLE when it exists.
%%\item $\bar{Y}_m$ is the sample mean, $\frac{1}{m}\sum_{i=1}^m g(Y_i)$
%\end{itemize}
%\newpage
{\small
\noindent \textbf{LCM MLE Algorithm}

\noindent \begin{algorithmic}[1]
\State Get an initial value, $\eta_1 = (0, \ldots 0)$.
\State \textbf{Sample} $Y_1, \ldots, Y_m$ from the distribution with parameter $\eta_{1}$.  
\State Set $ty.hull = \con(g(Y_1), \ldots, g(Y_m) )$.
\State Approximate 
\begin{align*}
\nabla \ell( \eta_1) \approx g(\yobs) - \frac{1}{m}\sum_{i=1}^m g(Y_i).
\end{align*}
\State Set $p_1 = \nabla \ell( \eta_1)$, $k=1$, $LCM.flag$ = FALSE, $c=0.2$.\\
%, $LCM.k=1$, 
%\State , $on.boundary$ = FALSE, $on.interior$ = FALSE.
%\State Set $face.cutoff = 0.30$.

\While{$\lVert \nabla \ell( \eta_k) \rVert > \epsilon$}
\State \textbf{Find} a step size $\alpha_k$ that satisfies the curvature condition \eqref{E:Wolfe-ll}
\begin{align*}%\label{E:curvature}
	 0 & \leq \nabla \ell( \eta_k + \alpha_k p_k)^T p_k \leq c \nabla \ell(\eta_k)^T p_k.
\end{align*}
%\State for some $0 < c < 1$. % (Calculating $\nabla \ell(\cdot)$ requires more sampling)

\State $\eta_{k+1} = \eta_k + \alpha_k p_k$.
\State \textbf{Sample} $Y_1, \ldots, Y_m$ from the distribution with parameter $\eta_{k+1}$.
\If{$LCM.flag=$TRUE}
	\State Restrict sample points to those in empirical face.
\EndIf
\State Call the resulting sample points $g(Y_{(1)}), \ldots, g(Y_{(p)})$.
\State \textbf{Update} $ty.hull$ to reflect new sample points, $g(Y_{(1)}), \ldots, g(Y_{(p)})$.\\
\State \textbf{Question: $g(\yobs) \in \rbd( \con(g(Y_{(1)}), \ldots, g(Y_{(p)}) ))$? }
%\If{Yes, $g(\yobs)$ is outside the convex hull}
%	\State  Keep sampling.  
%%	\State $on.boundary$ = FALSE.
%	\State Skip to estimating $\nabla \ell( \eta_{k+1})$.
%\ElsIf{No, $\yobs$ is inside the convex hull}
%	\State \textbf{The MLE exists}.  Finding it should be straightforward, (except 
%when 
%	\State it isn't ...) 
%	\State $on.boundary$ = FALSE, $on.interior$ = TRUE.
%	\State Skip to estimating $\nabla \ell( \eta_{k+1})$.
%\Else 
\If{Yes} %\Comment{$g(\yobs)$ is on the boundary of convex hull}
	\State \textbf{Either:}
	\State (1) the MLE exists but the sample just touches $g(\yobs)$, 
	\State (2) the MLE does \emph{not} exist; both $g(\yobs)$ and our sample points  
	\State are touching the boundary of $C$.
	\State \textbf{Find} the empirical face $F$ of $ty.hull$ on which $g(\yobs)$ lies.
%	\State \textbf{Calculate} $face.prop$, the proportion of the sample that falls on
%	\State this face.\\
%\newpage
	\If{$>60\%$ of the sample points are on $F$}
		\State Conclude that we are in case (2); case (1) is very unlikely.
		\State \textbf{Set} $LCM.flag$ = TRUE.
	\EndIf
\EndIf\\
%\State \textbf{Calculate} $\nabla \ell( \eta_{k+1})$ as follows: \label{Calc:nabla}
%\If{ $LCM.flag$ == FALSE }
%	\State $\nabla \ell( \eta_{k+1}) \approx g(\yobs) - \frac{1}{m}\sum_{i=1}^m g(Y_i)$
%\Else
	\State Approximate
	\begin{align} \label{E:nabla ell approx LCM}
	\nabla \ell( \eta_{k+1}) \approx g(\yobs) - \frac{1}{p}\sum_{i=1}^p g(Y_{(i)}).
	\end{align}

%, where the sample mean is restricted 
%	\State to empirical face points.
%\EndIf\\

\State \textbf{Find} the new search direction $p_{k+1}$, which must be an ascent 
direction.
\State This may be a normal or regression direction or $\nabla \ell( \eta_{k+1})$.
\State $k = k + 1$.
\EndWhile
\end{algorithmic}
}

There are several computational geometric operations implied in the above pseudocode:
\begin{itemize}
\item Find the convex hull of a set of points.
\item Determine if a point is in the interior, exterior, or  boundary of a convex hull.
\item Determine the face of a convex hull on which a points lies in the relative interior.
\item Find a GDOR.
\end{itemize}

Before we can discuss how to performs these, some background notation
and tools are necessary.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Convex polytope representation}
As discussed in Section~\ref{S:Convex analysis}, a convex polyhedron $C$, which we 
may think of as the convex hull of a finite set of points $V$, can equivalently
be expressed as the intersection of a finite collect of closed half-spaces.  These
representations are referred to as the V-representation and the H-representation, 
respectively.

\subsection{V-representation} \label{S:V-rep}
The \texttt{rcdd} package requires a V-representation be inputed in the following form:
\begin{align} \label{E:V-rep}
	\left[\begin{array}{ccc}l & b & V\end{array}\right]
\end{align}
where $l$ and $b$ are column vectors and $V$ is a matrix such that the polytope
is the set of points $y$ of the form
\begin{align*}
	y = \lambda^T V
\end{align*}
where
\begin{align*}
	\lambda_j \geq 0, \quad \text{where $l_j = 0$}
\end{align*}
and 
\begin{align*}
	\sum_j b_j \lambda_j = 1, \quad \text{unless all $b_j = 0$.}
\end{align*}
The entries for $l$ and $b$ in each row define how the linear combination of 
points in the same row in $V$ should be taken,
\begin{align*}
	l &= \text{0 or 1.  A 0 indicates nonnegative coefficients only,}\\
	b &= \text{0 or 1.  A 1 indicates this row should be included in sum to one.}
\end{align*}
For finite polytopes of a finite set of points, we take $l = 0$ and $b = 1$.  
We may also be interested in the V-representation for rays (such as in the
case of a cone), in which case we can set $b=0$.  
This representation can also handle more abstract generators that 
are not of interest to us here.

\subsection{H-representation} \label{S:H-rep}
The \texttt{rcdd} package requires a H-representation be inputed in the following form:
\begin{align} \label{E:H-rep}
	\left[\begin{array}{ccc}	0 & b_1 & -A_1 \\ 1 & b_2 & -A_2
	\end{array}\right]
\end{align}
where $b_1$ and $b_2$ are column vectors and $A_1$ and $A_2$ are matrices 
of coefficients characterizing the finite set of 
linear equalities and inequalities
\begin{align} \label{E:H-repx}
\begin{split}
	A_1 x &\leq b_1 \\
	A_2 x &= b_2.
\end{split}
\end{align}
Thus the zero in the first column corresponds to an equality constraint, a one to
an inequality constraint.
The set of points $x$ that satisfy the above constraints is equivalent to the
convex polyhedron.

The H-representation provides a direct
way to assess whether some new point $q$ is in or out of the convex hull
simply by plugging it in for $x$ in \eqref{E:H-repx} and seeing if the equalities
and inequalities are satisfied, as described in Section~\ref{S:H-rep inquiry}

\subsection{V-rep to H-rep and back}
The \texttt{rcdd} package provides us with a simple function \texttt{scdd}
to go back and forth between the H-representation and V-representation, taking as input
the matrix form described by either \eqref{E:V-rep} or \eqref{E:H-rep} accompanied
by its representation type (``H'' or ``V"), and returning its alternate representation, e.g.,
\begin{verbatim}
Hrep <- scdd( Vrep, representation = "V" )
\end{verbatim}

However, the operation of V-representation $\rightarrow$ H-representation 
can be a very computationally intensive operation; \citet{Geyer:2009} describes


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Finding the convex hull}
Finding the convex hull from a set of points is a well-studied problem.  It 
is of interest to us here because we want to ``discover" the convex support $C$
by repeatedly taking MCMC samples in different areas close to $g(\yobs)$ (the
process by which we get these samples to approach $g(\yobs)$ is discussed
in more detail in Section~\ref{S:Example 9node}).  The 
set of points we have to work with then are generated from repeated MCMC
samples of canonical statistics.

We can do two things with these set of points: we can try to determine the
extreme points of $C$, that is, the minimal V-representation, or we can try to find
the H-representation.  Determining the extreme points of $\con C$ 
is a much simpler problem which \citet{Fukuda:2004} refers to as ``redundancy 
removal" as opposed to the latter which is the usual ``convex hull problem".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Extreme points}
Given a set of non-unique points $V$, we can find the extreme points in two steps:
first, find the unique points in this sample, and then eliminate redundant generators.  The first operation can be done using the \texttt{unique} function, 
which is in the \texttt{base} package of R, the second requires defining a V-representation and then applying the \texttt{redundant} function in the \texttt{rcdd}
package which eliminates the redundant generators.
We demonstrate this using 10 samples of a two-dimensional vector:
\begin{verbatim}
> sample.gy <- t(matrix( c(
+ 19, 11,
+ 21, 14,
+ 19, 11,
+ 21, 13,
+ 21, 13,
+ 23, 21,
+ 14, 3,
+ 21, 16,
+ 15, 4,
+ 17, 8), ncol = 10) )
> sample.gy.unique <- unique( sample.gy ) 
> ( sample.gy.Vrep 	 <- cbind( 0, 1, sample.gy.unique ) )
     [,1] [,2] [,3] [,4]
[1,]    0    1   19   11
[2,]    0    1   21   14
[3,]    0    1   21   13
[4,]    0    1   23   21
[5,]    0    1   14    3
[6,]    0    1   21   16
[7,]    0    1   15    4
[8,]    0    1   17    8
> ( sample.gy.reduced <- redundant( d2q(sample.gy.Vrep), rep = "V" ) )
$output
     [,1] [,2] [,3] [,4]
[1,] "0"  "1"  "21" "13"
[2,] "0"  "1"  "23" "21"
[3,] "0"  "1"  "14" "3" 
[4,] "0"  "1"  "15" "4" 
attr(,"representation")
[1] "V"

$redundant
[1] 1 2 6 8

$new.position
[1] 0 0 1 2 3 0 4 0
\end{verbatim}
In the first step, $(19,11)$ and $(21,13)$ each appear twice and are eliminated
using \texttt{unique}.  Then, a V-rep of these points is constructed.  Before
passing to \texttt{redundant}, we first convert it to rational number format
with the function \texttt{d2q}.  The \texttt{redundant} function, which could
be applied to both rational and decimal format, then eliminates
all but four of these points.  These can be converted back to decimal format
using \texttt{q2d}.  We prefer doing any operation that involves a comparison
with rational numbers for the reasons discussed earlier.

It would have been possible to go directly from the sample to the reduced 
representation using \texttt{redundant}, but this step reduces the calculations
performed by \texttt{redundant}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{H-representation of the convex hull}
We can convert this to H-representation of the convex hull 
using the \texttt{scdd} function described previously:
\begin{verbatim}
> ( sample.gy.Hrep <- scdd( sample.gy.reduced$output, rep = "V" ) )
$output
     [,1] [,2]   [,3]   [,4]
[1,] "0"  "11"   "-1"   "1" 
[2,] "0"  "37/2" "-3/2" "1" 
[3,] "0"  "71"   "-4"   "1" 
[4,] "0"  "-25"  "2"    "-1"
attr(,"representation")
[1] "H"
\end{verbatim}

\hl{This route of \texttt{unique} $\rightarrow$ \texttt{redundant} $\rightarrow$ 
\texttt{scdd} is our preferred approach to obtain the H-representation of the convex hull from a set of points since \texttt{scdd} is the most computationally demanding
operation.}  In fact, it is so computationally expensive that we will avoid
this where possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Adding points to convex hull}
Suppose we generated additional points and wanted to combine these with the previously generated convex hull.  We obtain the non-redundant points as before:
\begin{verbatim}
> sample.gy2 <- t(matrix( c(
+ 20, 14,
+ 11, 1,
+ 19, 10,
+ 12, 3,
+ 15, 5,
+ 18, 7,
+ 15, 6,
+ 20, 13,
+ 17, 9,
+ 18, 5), ncol=10) ) 
> sample.gy2.unique 	<- unique( sample.gy2 ) 
> ( sample.gy2.Vrep 	 <- cbind( 0, 1, sample.gy2.unique ) )
      [,1] [,2] [,3] [,4]
 [1,]    0    1   20   14
 [2,]    0    1   11    1
 [3,]    0    1   19   10
 [4,]    0    1   12    3
 [5,]    0    1   15    5
 [6,]    0    1   18    7
 [7,]    0    1   15    6
 [8,]    0    1   20   13
 [9,]    0    1   17    9
[10,]    0    1   18    5
> ( sample.gy2.reduced <- redundant( d2q(sample.gy2.Vrep), rep = "V" ) )
$output
     [,1] [,2] [,3] [,4]
[1,] "0"  "1"  "20" "14"
[2,] "0"  "1"  "11" "1" 
[3,] "0"  "1"  "12" "3" 
[4,] "0"  "1"  "20" "13"
[5,] "0"  "1"  "18" "5" 
attr(,"representation")
[1] "V"

$redundant
[1] 3 5 6 7 9

$new.position
 [1] 1 2 0 3 0 0 0 4 0 5
\end{verbatim}
%
%> ( sample.gy2.Hrep <- scdd( sample.gy2.reduced$output, rep = "V" ) )
%$output
%     [,1] [,2]    [,3]   [,4] 
%[1,] "0"  "67"    "-4"   "1"  
%[2,] "0"  "37/4"  "-1"   "7/4"
%[3,] "0"  "-21"   "2"    "-1" 
%[4,] "0"  "-27/2" "11/8" "-1" 
%[5,] "0"  "20"    "-1"   "0"  
%attr(,"representation")
%[1] "H"
\hl{WHAT IS BEING STORED?  IF WE KEPT AROUND THE V-REP, THEN COULD
DO UNIQUE() ON THE POINTS, AND GO AS BEFORE.  OR, IF WE KEEP H-REP, THEN
WE WANT TO FIRST CONVERT BACK TO V-REP AND THEN SCDD?}
% First sample H-rep
%[1,] "0"  "11"   "-1"   "1" 
%[2,] "0"  "37/2" "-3/2" "1" 
%[3,] "0"  "71"   "-4"   "1" 
%[4,] "0"  "-25"  "2"    "-1"

We then combine these new, reduced points with the extreme points of the previously
obtained convex hull.  On this combined set, we apply \texttt{unique}, 
\texttt{redundant} as before, and, if we desire the H-representation, \texttt{scdd}.

\begin{verbatim}
> sample.gy.combined <- unique( rbind( sample.gy.reduced$output, 
sample.gy2.reduced$output ) )
> ( sample.gy.combined <- redundant( sample.gy.combined, rep = "V" ) )
$output
     [,1] [,2] [,3] [,4]
[1,] "0"  "1"  "21" "13"
[2,] "0"  "1"  "23" "21"
[3,] "0"  "1"  "11" "1" 
[4,] "0"  "1"  "12" "3" 
[5,] "0"  "1"  "18" "5" 
attr(,"representation")
[1] "V"

$redundant
[1] 3 4 5 8

$new.position
[1] 1 2 0 0 0 3 4 0 5

> ( sample.gy.Hrep <- scdd( sample.gy.combined$output, rep = "V" ) )
$output
     [,1] [,2]      [,3]    [,4] 
[1,] "0"  "43"      "-8/3"  "1"  
[2,] "0"  "37/4"    "-1"    "7/4"
[3,] "0"  "-21"     "2"     "-1" 
[4,] "0"  "-183/11" "18/11" "-1" 
[5,] "0"  "71"      "-4"    "1"  
attr(,"representation")
[1] "H"
\end{verbatim}

The separate and combined convex hulls are displayed in Figure~\ref{F:combined-hull}.
There are five inequalities here, one for each side.
\begin{figure}[h]
\begin{center}
\includegraphics[width=4.5in]{combined-hull-norm}
\end{center}
\caption{The convex hulls for two separate ten-point samples (dotted lines).  The 
convex hull for the combined is the solid line.  Boundaries of the normal cones
at two points, (20,31/3), and (21,13), shifted to start at those two points, are depicted as arrows.}
\label{F:combined-hull}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Point on exterior, interior, and boundary of a convex hull}
Determining whether $g(\yobs)$ lies on the exterior, interior, or boundary
of a convex hull is of central importance to our method.  We present two 
different approaches here.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Determining boundary points via H-representation of convex hull}
\label{S:H-rep inquiry}
We first describe a more intuitive but less desirable approach.  It is less preferable because it requires obtaining the H-representation, 
which can be expense to obtain from the V-representation, 
especially as the dimension increases.  In fact, the number of inequalities 
is often exponential in the number of dimensions \citep{Fukuda:2008}.

We pick an exterior, interior, and boundary point by examining 
Figure~\ref{F:combined-hull}: (20,10), (20,12), (21,13).  To this vector, we multiply
 by the matrix $A$ from the H-representation (we assume here that we have 
 all inequalities)
 and subtract $b$.  The sign of the resulting quantities tells us if a 
 particular inequality has been satisfied: positive indicates that it has not, 
 negative indicates that it is strictly satisfied, and a zero indicates that it is
 met with an equality.  Thus for each inquiry point, we need only largest
 of the sign of these to make our conclusion.
\begin{verbatim}
> x <- rbind( c(20,10), c(20,12), c(21,13) )
> l <- sample.gy.Hrep$output[ ,1]
> b <- sample.gy.Hrep$output[ ,2]
> a <- sample.gy.Hrep$output[ ,-c(1,2)]
> a <- qneg( a )
> ( axb <- qmatmult( a, t(x) ) )
     [,1]     [,2]     [,3]    
[1,] "1/3"    "-5/3"   "0"     
[2,] "-27/4"  "-41/4"  "-11"   
[3,] "-9"     "-7"     "-8"    
[4,] "-67/11" "-45/11" "-52/11"
[5,] "-1"     "-3"     "0"     
> axb <- sweep( axb, 1, b, FUN=qmq ) # subtract b
> apply( axb, 2, function(pair) max(qsign(pair)) )
[1]  1 -1  0
\end{verbatim}

Here we have five inequalities.
 The first point (20,10) satisfies 4 of the 5, but violates the first, with
 a positive result of $\frac{1}{3}$ and thus we get a positive sign, indicating
 an exterior point.  The second point (20,12) is strictly negative on all five inequalities, indicating that they have all been strictly satisfied, 
 resulting in a negative sign.  Finally, the point (21,13) satisfies three inequalities strictly, and meets
two with strict equality.  This makes sense since (21,13) is an exterior point
of the hull and thus connects two sides.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Strongly separating hyperplane} \label{S:Strong H}
\citet{Fukuda:2008} presents a more efficient way to determine whether a single 
inquiry point $q$ is in or out of the convex hull of many other points $p_i$.  
The approach looks to find a strongly separating hyperplane $H$ between a 
point $q$ and the convex hull of a set of points $\{p_i : i \in I\}$
\begin{align*}
	H = \{x : z^T x = z_0\}
\end{align*}
where $z$ is a vector and $z_0$ a scalar satisfying
\begin{align*}
		z^T p_i &< z_0 \quad i \in I \\
		z^Tq &> z_0.
\end{align*}
This can be accomplished by solving the linear programming problem
\begin{align*}
	\text{maximize } 	&f(z_0, z) = z^q - z_0 \\
	\text{subject to } 	&z^T p_i - z_0 \leq 0, \quad i \in I \\
						&z^Tq - z \leq 1, 
\end{align*}
where the last inequality is artificially added so that the linear program 
has a bounded solution \citep{Fukuda:2008,rcdd:R}.  If the maximized value of 
$f$ is strictly positive, then a strongly separating hyperplane exists and 
$q$ is in the exterior of the convex hull.  Otherwise, $q$ is on the boundary or 
the interior.  Note that it does not distinguish between these latter two cases.

\citet{rcdd:R} provide a general linear programming routine in the
\texttt{lpcdd} function in the \texttt{rcdd} package which can be applied to solve this problem.  The function maximizes the linear function $x \mapsto a^x$ 
subject to the constraint that $x$ lie in the polyhedral convex set having 
the H-representation specified.  It has also been built to work with 
rational arithmetic.
We demonstrate its use on an exterior, boundary, and interior
point, using the convex hull we constructed in the previous section.  Note that \texttt{lpcdd} can be applied to the V-representation of points, eliminating
the need for a call to \texttt{scdd}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Exterior point}
Let $q = (20,10)$, on the exterior.
\begin{verbatim}
> q <- c(20,10) 
> ( hull.pts <- sample.gy.combined$output[ , -c(1:2) ] ) # get points in hull
     [,1] [,2]
[1,] "21" "13"
[2,] "23" "21"
[3,] "11" "1" 
[4,] "12" "3" 
[5,] "18" "5" 
> hrep <- cbind( 0, 0, 1, qneg(hull.pts) )	# s.t. 1st ineq
> ( hrep <- rbind( hrep, c(0, 1, 1, -q) ) )	# 2nd (artifical) ineq
     [,1] [,2] [,3] [,4]  [,5] 
[1,] "0"  "0"  "1"  "-21" "-13"
[2,] "0"  "0"  "1"  "-23" "-21"
[3,] "0"  "0"  "1"  "-11" "-1" 
[4,] "0"  "0"  "1"  "-12" "-3" 
[5,] "0"  "0"  "1"  "-18" "-5" 
[6,] "0"  "1"  "1"  "-20" "-10"
> lpcdd( hrep, d2q( c(-1, q) ), minimize = FALSE )$optimal.value
[1] "1"
\end{verbatim}
The maximum value of 1 is strictly positive so $(20,10)$ is on the exterior, as expected.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Interior point}
Let $q = (20,12)$.
\begin{verbatim}
> q <- c(20,12) 
>  hull.pts <- sample.gy.combined$output[ , -c(1:2) ]  # get points in hull
> hrep <- cbind( 0, 0, 1, qneg(hull.pts) )	# s.t. 1st ineq
> ( hrep <- rbind( hrep, c(0, 1, 1, -q) ) )	# 2nd (artifical) ineq
     [,1] [,2] [,3] [,4]  [,5] 
[1,] "0"  "0"  "1"  "-21" "-13"
[2,] "0"  "0"  "1"  "-23" "-21"
[3,] "0"  "0"  "1"  "-11" "-1" 
[4,] "0"  "0"  "1"  "-12" "-3" 
[5,] "0"  "0"  "1"  "-18" "-5" 
[6,] "0"  "1"  "1"  "-20" "-12"
> lpcdd( hrep, d2q( c(-1, q) ), minimize = FALSE )$optimal.value
[1] "0"
\end{verbatim}
The maximum value of $f$ here is 0, so $(20,12)$ is on the boundary or the interior.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Boundary point}
Let $q = (21,13)$, one of the extreme points of the convex hull.
\begin{verbatim}
> q <- c(21,13) 
>  hull.pts <- sample.gy.combined$output[ , -c(1:2) ]  # get points in hull
> hrep <- cbind( 0, 0, 1, qneg(hull.pts) )	# s.t. 1st ineq
> ( hrep <- rbind( hrep, c(0, 1, 1, -q) ) )	# 2nd (artifical) ineq
     [,1] [,2] [,3] [,4]  [,5] 
[1,] "0"  "0"  "1"  "-21" "-13"
[2,] "0"  "0"  "1"  "-23" "-21"
[3,] "0"  "0"  "1"  "-11" "-1" 
[4,] "0"  "0"  "1"  "-12" "-3" 
[5,] "0"  "0"  "1"  "-18" "-5" 
[6,] "0"  "1"  "1"  "-21" "-13"
> lpcdd( hrep, d2q( c(-1, q) ), minimize = FALSE )$optimal.value
[1] "0"
\end{verbatim}
The maximum value of $f$ here is again 0, so $(21,13)$ is on the boundary or the interior, we do not know which.  
%If we want to confirm that the point is indeed
%on the boundary of the convex hull, we must use H-representation of the hull
%directly as described in Section~\ref{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{S:linearity}
Thus far we have advocated using V-representations of convex hulls and using
the \texttt{lpcdd} function to determine whether or not an inquiry point is
in the exterior of the hull.  To then determine if the point is on the boundary
or the interior (the crucial question), one could apply the 
H-representation approach described in 
Section~\ref{S:H-rep inquiry}, but as noted, this is computationally inefficient.
Here we describe another approach that is not only more computationally efficient
but also provides us with much more useful information in the context of our
MLE search objective.

\citet{Geyer:gdor} defines the \emph{linearity} of a set of points $W$ to be
\begin{align*}
	L = \{ w \in W: -w \in \con( W ) \}.
\end{align*}
Let $V$ the set of extreme points of a convex hull and let $q$ be a point of inquiry.
Define 
\begin{align*}
W = \{ v - q: v \in V \},
\end{align*}
which is in fact $T_V(q)$.  If $\con( V ) = C$ the
polyhedral convex support of an exponential family and $q = g(\yobs)$, then the set 
$L$ here is the same $L$ as in Theorem~\ref{Thm:L-GDOR}.    
By Theorem~\ref{Thm:C-H} and Corollary~\ref{Cor:spanL}, if a GDOR 
exists then $\spanl L$  
determines the hyperplane $H$ and also the convex support of the LCM by
\begin{align*}
	C \cap H = C \cap (g(\yobs) + \spanl L).
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{linearity} function}
The \texttt{linearity} function in the \texttt{rcdd} takes as input rays in 
the form of $W$ above and identities the generators that characterize
a vector subspace.  It can take as input the V- or H-representation and solves the 
following linear programming problem for each $w \in W$:
\begin{align*}
	\text{maximize } 	&\inner{w,\delta}\\
	\text{subject to } 	&\inner{v,\delta} \geq 0, \quad v \in W \setminus \{w\}
\end{align*}
We demonstrate its functionality on an interior
point and two points on the boundary, using the same convex hull V-representation
as before.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Interior point}
Let $q = (20,12)$, a point on the interior.
\begin{verbatim}
> q <- c(20,12)
> ( W <- sweep( hull.pts, 2, q, FUN = qmq ) )
     [,1] [,2] 
[1,] "1"  "1"  
[2,] "3"  "9"  
[3,] "-9" "-11"
[4,] "-8" "-9" 
[5,] "-2" "-7" 
> W <- cbind( 0, 0, W )
> ( lin.active <- linearity( W, rep = "V" ) )
[1] 1 2 3 4 5
> ( L <- W[ lin.active, , drop=FALSE] )
     [,1] [,2] [,3] [,4] 
[1,] "0"  "0"  "1"  "1"  
[2,] "0"  "0"  "3"  "9"  
[3,] "0"  "0"  "-9" "-11"
[4,] "0"  "0"  "-8" "-9" 
[5,] "0"  "0"  "-2" "-7" 
\end{verbatim}
Here, \texttt{linearity} returned the indices for all vectors put in.  Adding
back $q$ to the rays will return the original extreme points of the convex hull.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Boundary point, two-dimensional face}
Let $q = (20,31/3)$, which we found by plugging 20 into the H-representation
of the hull.  This point falls on the line $y = \frac{8}{3}x - 43$ between
the points $(18,5)$ and $(21,13)$. Of course in the ERGM setting we consider,
it is impossible to generate an non-integer count of network structures,
but we ignore this issue here since we simply wish to illustrate the 
behavior of \texttt{linearity}.
\begin{verbatim}
> q <- c("20","31/3")
> ( W <- sweep( hull.pts, 2, q, FUN = qmq ) )
     [,1] [,2]   
[1,] "1"  "8/3"  
[2,] "3"  "32/3" 
[3,] "-9" "-28/3"
[4,] "-8" "-22/3"
[5,] "-2" "-16/3"
> W <- cbind( 0, 0, W )
> ( lin.active <- linearity( W, rep = "V" ) )
[1] 1 5
> ( L <- W[ lin.active, , drop=FALSE] )
     [,1] [,2] [,3] [,4]   
[1,] "0"  "0"  "1"  "8/3"  
[2,] "0"  "0"  "-2" "-16/3"
> hull.pts[ lin.active, , drop=FALSE ]
     [,1] [,2]
[1,] "21" "13"
[2,] "18" "5" 
\end{verbatim}
The \texttt{linearity} function identifies the rays in opposite directions
running along $y = \frac{8}{3}x + 43$, starting at $q$.  That is, it has
identified a two-dimensional face, the line segment between $(18,5)$ and $(21,13)$
on which $q$ lies in the relative interior.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Boundary point, one-dimensional face}
Let $q = (21,13)$.
\begin{verbatim}
> q <- c(21,13)
> ( W <- sweep( hull.pts, 2, q, FUN = qmq ) )
     [,1]  [,2] 
[1,] "0"   "0"  
[2,] "2"   "8"  
[3,] "-10" "-12"
[4,] "-9"  "-10"
[5,] "-3"  "-8" 
> W <- cbind( 0, 0, W )
> ( lin.active <- linearity( W, rep = "V" ) )
[1] 1
> ( L <- W[ lin.active, , drop=FALSE] )
     [,1] [,2] [,3] [,4]
[1,] "0"  "0"  "0"  "0" 
\end{verbatim}
In this example, \texttt{linearity} identifies only the zero vector, which
trivially satisfies the definition of a subspace.  Here, the point $q = (21,13)$
is a one-dimensional face, lying in the relative interior of itself.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Empirical face}
We began this chapter under the more realistic setting that we do not know
$C$ and are generating MCMC samples in the sample space to explore it.  
Thus the convex hulls we have to work are those of accumulated samples,
after it has been ascertained that the inquiry point is either in the interior
or boundary of the hull.  The \texttt{linearity} function applied to the extreme points of a hull identifies the face $F$ on which $q$ lies in the relative interior.  
If \texttt{linearity} returns all the indices, then $q$ is an interior point.  Otherwise, \texttt{linearity} returns the indices that characterize the extreme
points of a face on the boundary of the hull.  

%We will often be interested in determining which points in 
%a new sample fall on the face we previously defined.  We could
%\begin{enumerate}
%\item Apply \texttt{lpcdd} for every point in the sample.
%\item Get the H-representation of the face.  Apply the inequalities to every point in the sample.
%\item Find the set $S \cap H$ of all points that comprise the face.  The set is bounded in size because the sample space is finite and discrete (though this may
%not be particularly reassuring).  Then compare the sample points to this set for matches. 
%\end{enumerate}
%The appropriateness of each method may depend on the number of dimensions of the 
%sample space.  For high dimensional problems, \texttt{scdd} should be avoided,
%suggesting that perhaps the first way is best.  However, for low dimensional 
%sample spaces, the \texttt{scdd} approach to H-representation may be fastest.

%points in $S = g(\YY)$ that are in the
%hyperplane $H$, that is, the points on the face of $C$ in which
%$g(\yobs)$ lies in the relative interior
%\begin{align*}
%S \cap H = S \cap(\yobs + \spanl L).
%\end{align*}

%Let $\widetilde{T}_C(x)$ be the empirical tangent cone at the point $x$ constructed 
%from a set of points $W$ all in $C$.  That is,
%\begin{align*}
%	\widetilde{T}_C(x) = \{ w - x: w \in W\}.
%\end{align*}
%Then for $V = \widetilde{T}_C(g(\yobs))$, the linearity corresponds to the set of 
%points from $W$ (shifted by $g(\yobs)$) that form what we refer to as the empirical 
%face $F$.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Normal and tangent cones}
We may be interested in the normal cone and tangent cones after it has been
determined that $q$ is on the boundary of a  hull.  The approaches described
in this section rely on an H-representation of the convex hull and so we avoid 
using these in our algorithm.  Nevertheless, they are useful to have for
comparison purposes.

The H-representation of a polyhedral convex set $C$ can be presented as
\begin{align*}
	C = \{ x: \inner{a_i, x} \leq b_i, i \in I \text{ and } 
				\inner{a_i, x} = b_i, i \in E \}.
\end{align*}
The tangent cone at a particular point $x \in C$ can then simply be gleaned from 
this H-representation by
\begin{align*}
	T_C(x) = \{ y: \inner{a_i, y} \leq 0, i \in A \text{ and } 
				\inner{a_i, y} = 0, i \in E \}
\end{align*}
where 
\begin{align*}
	A = \{ i \in I: \inner{a_i, x} = b_i \}
\end{align*}
is the active set of inequality constraints (the inactive constraints have been
 dropped, and now $x$ is the new origin).
%Actually, tangent cone we have
%already been using: it is the space spanned by the rays identified by \texttt{linearity}.  Passing these rays to \texttt{scdd} will return an H-representation
%of the tangent cone.
We may then use the polarity of the tangent and normal cones to read the 
V-representation of the normal cone right off the H-representation 
of the tangent cone:
\begin{align*}
	N_C(x) = \pos( \{ a_i: i \in A \cup E \} \cup \{ -a_i: i \in E \} )
\end{align*}
We apply this to the same boundary points and hull (where there are no 
equality constraints).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boundary point, two-dimensional face}
\begin{verbatim}
> q <- as.matrix( c("20","31/3") )
> sample.gy.Hrep
$output
     [,1] [,2]      [,3]    [,4] 
[1,] "0"  "43"      "-8/3"  "1"  
[2,] "0"  "37/4"    "-1"    "7/4"
[3,] "0"  "-21"     "2"     "-1" 
[4,] "0"  "-183/11" "18/11" "-1" 
[5,] "0"  "71"      "-4"    "1"  
attr(,"representation")
[1] "H"

> l <- sample.gy.Hrep$output[ ,1]
> b <- sample.gy.Hrep$output[ ,2]
> a <- sample.gy.Hrep$output[ ,-c(1,2)]
> ( active <- qpq( qmatmult( a, q ), b ) == "0" )
      [,1]
[1,]  TRUE
[2,] FALSE
[3,] FALSE
[4,] FALSE
[5,] FALSE
> tcone.Hrep <- sample.gy.Hrep$output[ active, , drop=FALSE]
> tcone.Hrep[ ,2 ] <- "0"
> tcone.Hrep
     [,1] [,2] [,3]   [,4]
[1,] "0"  "0"  "-8/3" "1" 
> # normal cone
> ( ncone.Vrep <- qneg( tcone.Hrep ) )
     [,1] [,2] [,3]  [,4]
[1,] "0"  "0"  "8/3" "-1"
\end{verbatim}
Since this point lies in the relative interior of the line segment,
the normal cone consists of a single direction, depicted in Figure~\ref{F:combined-hull}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boundary point, one-dimensional face}
\begin{verbatim}
> q <- as.matrix( c("21","13") )
> sample.gy.Hrep
$output
     [,1] [,2]      [,3]    [,4] 
[1,] "0"  "43"      "-8/3"  "1"  
[2,] "0"  "37/4"    "-1"    "7/4"
[3,] "0"  "-21"     "2"     "-1" 
[4,] "0"  "-183/11" "18/11" "-1" 
[5,] "0"  "71"      "-4"    "1"  
attr(,"representation")
[1] "H"

> l <- sample.gy.Hrep$output[ ,1]
> b <- sample.gy.Hrep$output[ ,2]
> a <- sample.gy.Hrep$output[ ,-c(1,2)]
> ( active <- qpq( qmatmult( a, q ), b ) == "0" )
      [,1]
[1,]  TRUE
[2,] FALSE
[3,] FALSE
[4,] FALSE
[5,]  TRUE
> tcone.Hrep <- sample.gy.Hrep$output[ active, , drop=FALSE]
> tcone.Hrep[ ,2 ] <- "0"
> tcone.Hrep
     [,1] [,2] [,3]   [,4]
[1,] "0"  "0"  "-8/3" "1" 
[2,] "0"  "0"  "-4"   "1" 
> # normal cone
> ( ncone.Vrep <- qneg( tcone.Hrep ) )
     [,1] [,2] [,3]  [,4]
[1,] "0"  "0"  "8/3" "-1"
[2,] "0"  "0"  "4"   "-1"
\end{verbatim}
These boundaries the normal cone, shifted to start at $q$, are 
depicted in Figure~\ref{F:combined-hull}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Calculating a GDOR}
A GDOR $\delta$ is an vector in the relative interior of $N_C(g(\yobs))$ when
$N_C(g(\yobs))$ is not a vector subspace.  

By Theorem 7, $\delta$ isa GDOR if and only if
\begin{align*}
	\inner{w,\delta} & = 0 	\quad w \in L\\
	\inner{w,\delta} & < 0 	\quad w \in W \setminus L
\end{align*}
where $L$ is the linearity set and W is the tangent cone $T_C(g(\yobs))$.
\citet{Geyer:gdor} describes a linear programming problem designed to find one
such GDOR:
\begin{align*}
	\text{maximize } 	&\epsilon\\
	\text{subject to } 	&\epsilon \leq 1\\
	&\inner{v,\delta} = 0, \quad v \in L \\
	&\inner{v,\delta} \leq -\epsilon, \quad v \in W \setminus L.
\end{align*}
We demonstrate this in R, using the same convex hull and the points as before,
treating the convex hull as the convex support $C$ and the point $q$ as $g(\yobs)$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A GDOR when $g(\yobs)$ on two-dimensional face}
\begin{verbatim}
> q <-  c("20","31/3")
> d <- length( q )
> ( hull.pts <- sample.gy.combined$output[ , -c(1:2) ] ) # get points in hull
     [,1] [,2]
[1,] "21" "13"
[2,] "23" "21"
[3,] "11" "1" 
[4,] "12" "3" 
[5,] "18" "5" 
> ( W <- sweep( hull.pts, 2, q, FUN = qmq ) )
     [,1] [,2]   
[1,] "1"  "8/3"  
[2,] "3"  "32/3" 
[3,] "-9" "-28/3"
[4,] "-8" "-22/3"
[5,] "-2" "-16/3"
> W <- cbind( 0, 0, W )
> ( lin.active <- linearity( W, rep = "V" ) )
[1] 1 5
> ( objv <- d2q( c( rep(0,d), 1) ) )
[1] "0" "0" "1"
> hrep <- cbind( qneg(W), 0 ) 
> hrep[ lin.active, 1 ] <- 1
> hrep[ -lin.active, ncol(hrep) ] <- "-1"
> hrep <- rbind( hrep, c( 0, 1, rep(0,d), -1 ) )
> hrep
     [,1] [,2] [,3] [,4]    [,5]
[1,] "1"  "0"  "-1" "-8/3"  "0" 
[2,] "0"  "0"  "-3" "-32/3" "-1"
[3,] "0"  "0"  "9"  "28/3"  "-1"
[4,] "0"  "0"  "8"  "22/3"  "-1"
[5,] "1"  "0"  "2"  "16/3"  "0" 
[6,] "0"  "1"  "0"  "0"     "-1"
> lpout <- lpcdd( hrep, objv, minimize = FALSE )
> ( gdor  <- lpout$primal.solution[ -(d+1) ] )
[1] "1"    "-3/8"
\end{verbatim}
The GDOR of $(1, -\frac{3}{8} )$ agrees with the one found earlier.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A GDOR when $g(\yobs)$ on one-dimensional face}
\begin{verbatim}
> q <-  c("21","13")
> d <- length( q )
> ( hull.pts <- sample.gy.combined$output[ , -c(1:2) ] ) # get points in hull
     [,1] [,2]
[1,] "21" "13"
[2,] "23" "21"
[3,] "11" "1" 
[4,] "12" "3" 
[5,] "18" "5" 
> ( W <- sweep( hull.pts, 2, q, FUN = qmq ) )
     [,1]  [,2] 
[1,] "0"   "0"  
[2,] "2"   "8"  
[3,] "-10" "-12"
[4,] "-9"  "-10"
[5,] "-3"  "-8" 
> W <- cbind( 0, 0, W )
> ( lin.active <- linearity( W, rep = "V" ) )
[1] 1
> ( objv <- d2q( c( rep(0,d), 1) ) )
[1] "0" "0" "1"
> hrep <- cbind( qneg(W), 0 ) 
> hrep[ lin.active, 1 ] <- 1
> hrep[ -lin.active, ncol(hrep) ] <- "-1"
> hrep <- rbind( hrep, c( 0, 1, rep(0,d), -1 ) )
> hrep
     [,1] [,2] [,3] [,4] [,5]
[1,] "1"  "0"  "0"  "0"  "0" 
[2,] "0"  "0"  "-2" "-8" "-1"
[3,] "0"  "0"  "10" "12" "-1"
[4,] "0"  "0"  "9"  "10" "-1"
[5,] "0"  "0"  "3"  "8"  "-1"
[6,] "0"  "1"  "0"  "0"  "-1"
> lpout <- lpcdd( hrep, objv, minimize = FALSE )
> ( gdor  <- lpout$primal.solution[ -(d+1) ] )
[1] "2"    "-5/8"
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subsampling}
Given a particular face characterized by an empirical GDOR, we need to
find points in a new sample that fall on this face.  This is straightforward to
do since by definition the GDOR $\delta$ is orthogonal to any point in that face,
so we may simply take the dot product 
We demonstrate this at the point $(20, 31/3)$, using the GDOR that we just 
obtained in the previous section, $\delta = (1, -3/8)$.
\begin{verbatim}
> gdor <- as.matrix(c( "1", "-3/8" ) )
> q <- c( "20", "31/3" )
> sample.gy.3 <- t(matrix( c(
+ "17", "7/3",
+ "18", "5",
+ "19", "23/3",
+ "20", "31/3",
+ "21", "13",
+ "22", "47/3",
+ "20", "10",
+ "20", "32/3",
+ "19", "8",
+ "19", "25/3"
+ ), ncol = 10) )
> W <- sweep( sample.gy.3, 2, q, FUN = qmq )
> qmatmult( W, gdor )
      [,1]  
 [1,] "0"   
 [2,] "0"   
 [3,] "0"   
 [4,] "0"   
 [5,] "0"   
 [6,] "0"   
 [7,] "1/8" 
 [8,] "-1/8"
 [9,] "-1/8"
[10,] "-1/4"
\end{verbatim}
This method identifies the first six points as being orthogonal to $\delta$.
If we are using the same face as before of the line segment between (18,5) and (21,13), then actually the first and sixth points, $(17, 7/3)$ and $(22,47/3)$, 
are \emph{not} on the face.  This may cause for concern, but let us 
think about the context in which we will use this.  From an MCMC sample of points,
we identify via \texttt{linearity} a face on which $g(\yobs)$ lies in the relative
interior and then find a GDOR for this face.  It is impossible to generate any
points outside of $C$, so the additional points we find are in fact legitimate 
points of the face.  We may still want to be aware that what we had previously
perceived as the face was incomplete; thus we may need to keep track of a 
V-representation of the face after all.

\section{Sampling from the LCM distribution}
It is not obvious that when we draw $g(Y_1), \ldots, g(Y_m)$ from the 
original model with parameter value $\eta$ that the subsample restricted to the 
support is in fact a sample from the LCM with parameter value $\eta$.  
But that is in fact example what Theorem~\ref{Thm:LCM} tells us: 
\begin{align*}
P_{LCM, \eta} = P_\eta( \cdot \mid g(Y) \in H ).
\end{align*}


